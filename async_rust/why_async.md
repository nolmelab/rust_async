# why async?

우리 모두는 Rust를 통해 빠르고 안전한 소프트웨어를 작성할 수 있다는 점을 좋아합니다. 하지만 비동기 프로그래밍이 이 비전에 어떻게 부합할까요?

비동기 프로그래밍 또는 줄여서 비동기라고도 하는 비동기 프로그래밍은 점점 더 많은 프로그래밍 언어에서 지원하는 동시 프로그래밍 모델입니다. 비동기/대기 구문을 통해 일반 동기 프로그래밍의 모양과 느낌을 대부분 유지하면서 적은 수의 OS 스레드에서 많은 수의 동시 작업을 실행할 수 있습니다.

## Async vs other concurrency models

동시 프로그래밍은 일반 순차 프로그래밍보다 덜 성숙하고 "표준화"되어 있습니다. 따라서 언어가 지원하는 동시 프로그래밍 모델에 따라 동시성을 다르게 표현합니다. 가장 널리 사용되는 동시성 모델에 대한 간략한 개요를 통해 비동기 프로그래밍이 더 넓은 동시 프로그래밍 분야에 어떻게 부합하는지 이해할 수 있습니다:

 - OS 스레드는 프로그래밍 모델을 변경할 필요가 없으므로 동시성을 매우 쉽게 표현할 수 있습니다. 그러나 스레드 간 동기화가 어려울 수 있으며 성능 오버헤드가 클 수 있습니다. 스레드 풀은 이러한 비용 중 일부를 완화할 수 있지만, 대규모 IO 바운드 워크로드를 지원하기에는 충분하지 않습니다.

- 이벤트 중심 프로그래밍은 콜백과 함께 사용하면 성능이 매우 뛰어날 수 있지만, 장황한 '비선형' 제어 흐름을 초래하는 경향이 있습니다. 데이터 흐름과 오류 전파를 따라가기 어려운 경우가 많습니다.

- 액터 모델은 모든 동시 연산을 액터라는 단위로 나누고, 분산 시스템에서와 마찬가지로 오류 메시지 전달을 통해 통신합니다. 액터 모델은 효율적으로 구현할 수 있지만 흐름 제어 및 재시도 로직과 같은 많은 실용적인 문제가 해결되지 않은 채로 남아 있습니다.

요약하면, 비동기 프로그래밍은 스레드와 코루틴의 인체공학적 이점을 대부분 제공하면서 Rust와 같은 저수준 언어에 적합한 고성능 구현을 가능하게 합니다.

## Async in rust vs other languages

비동기 프로그래밍은 많은 언어에서 지원되지만 일부 세부 사항은 구현마다 다릅니다. Rust의 비동기 구현은 몇 가지 점에서 대부분의 언어와 다릅니다:

- 러스트에서 Future는 비활성 상태이며 poll()을 할 때만 진행됩니다. Future를 삭제(Drop)하면 더 이상 진행되지 않습니다.

- Rust에서 비동기는 비용이 들지 않으므로 사용한 만큼만 비용을 지불하면 됩니다. 특히 힙 할당과 동적 디스패치 없이 비동기화를 사용할 수 있어 성능에 큰 도움이 됩니다! 또한 임베디드 시스템과 같은 제약된 환경에서도 비동기화를 사용할 수 있습니다.

- Rust는 내장 런타임을 제공하지 않습니다. 대신 커뮤니티에서 유지 관리하는 크레이트에서 런타임을 제공합니다. std에도 런타임이 있습니다.

- 단일 스레드 런타임과 멀티 스레드 런타임 모두 Rust에서 사용할 수 있으며, 각 런타임은 서로 다른 장단점이 있습니다.

## Async vs threads in Rust

Rust에서 비동기화에 대한 주요 대안은 std::thread를 통해 직접 또는 스레드 풀을 통해 간접적으로 OS 스레드를 사용하는 것입니다. 스레드에서 비동기로 또는 그 반대로 마이그레이션하려면 일반적으로 구현 및 (라이브러리를 빌드하는 경우) 노출된 공용 인터페이스 측면에서 대규모 리팩터링 작업이 필요합니다. 따라서 필요에 맞는 모델을 조기에 선택하면 개발 시간을 많이 절약할 수 있습니다.

스레드에는 CPU 및 메모리 오버헤드가 발생하므로 OS 스레드는 적은 수의 작업에 적합합니다. 유휴 스레드도 시스템 리소스를 소모하기 때문에 스레드를 생성하고 전환하는 데 많은 비용이 듭니다. 스레드 풀 라이브러리는 이러한 비용을 일부 완화하는 데 도움이 될 수 있지만 전부는 아닙니다. 하지만 스레드를 사용하면 코드를 크게 변경하지 않고도 기존 동기식 코드를 재사용할 수 있으므로 특정 프로그래밍 모델이 필요하지 않습니다. 일부 운영 체제에서는 스레드의 우선순위를 변경할 수도 있으므로 드라이버 및 기타 지연 시간에 민감한 애플리케이션에 유용합니다.

비동기화는 특히 서버 및 데이터베이스와 같이 IO 바인딩 작업이 많은 워크로드의 경우 CPU 및 메모리 오버헤드를 크게 줄여줍니다. 비동기 런타임은 적은 양의 (비싼) 스레드를 사용하여 많은 양의 (저렴한) 작업을 처리하기 때문에 OS 스레드보다 훨씬 더 많은 작업을 처리할 수 있습니다. 그러나 비동기 Rust는 비동기 함수에서 생성된 상태 머신과 각 실행 파일이 비동기 런타임을 번들링하기 때문에 더 큰 바이너리 블롭을 생성합니다.

마지막으로, 비동기 프로그래밍은 스레드보다 나은 것이 아니라 다른 것입니다. 성능상의 이유로 비동기가 필요하지 않은 경우 스레드가 더 간단한 대안이 될 수 있습니다.

### 예: 동시 다운로드

이 예제에서는 두 개의 웹 페이지를 동시에 다운로드하는 것이 목표입니다. 일반적인 스레드 애플리케이션에서는 동시성을 달성하기 위해 스레드를 스폰해야 합니다:

```rust
fn get_two_sites() {
    // Spawn two threads to do work.
    let thread_one = thread::spawn(|| download("https://www.foo.com"));
    let thread_two = thread::spawn(|| download("https://www.bar.com"));

    // Wait for both threads to complete.
    thread_one.join().expect("thread one panicked");
    thread_two.join().expect("thread two panicked");
}
```

그러나 웹 페이지를 다운로드하는 것은 작은 작업이며, 이렇게 적은 양의 작업을 위해 스레드를 생성하는 것은 상당히 낭비입니다. 대규모 애플리케이션의 경우 쉽게 병목 현상이 발생할 수 있습니다. 비동기 Rust에서는 추가 스레드 없이 이러한 작업을 동시에 실행할 수 있습니다:

```rust
async fn get_two_sites_async() {
    // Create two different "futures" which, when run to completion,
    // will asynchronously download the webpages.
    let future_one = download_async("https://www.foo.com");
    let future_two = download_async("https://www.bar.com");

    // Run both futures to completion at the same time.
    join!(future_one, future_two);
}
```

여기에서는 추가 스레드가 생성되지 않습니다. 또한 모든 함수 호출은 정적으로 전송되며 힙 할당도 없습니다! 하지만 처음부터 비동기식으로 코드를 작성해야 하며, 이 책이 이를 달성하는 데 도움이 될 것입니다.

<details>

<summary> 놀미 노트 </summary>

- async / await는 기본 쓰레드 풀을 시작할 때 갖고 있으므로 초기 시작 비용은 있습니다. 

</details>


