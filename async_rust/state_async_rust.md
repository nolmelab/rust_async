# The State of Asynchronous Rust 

비동기 러스트의 일부는 동기 러스트와 동일한 안정성 보장으로 지원됩니다. 다른 부분은 아직 개발 중이며 시간이 지남에 따라 변경될 예정입니다. 비동기 Rust를 사용하면 다음을 기대할 수 있습니다:

- 일반적인 동시 워크로드에 대한 뛰어난 런타임 성능.

- 수명 및 고정(Pinning)과 같은 고급 언어 기능과의 더 빈번한 상호 작용.

- 동기화 및 비동기 코드 간, 그리고 서로 다른 비동기 런타임 간에 일부 호환성 제약이 있습니다.

- 비동기 런타임 및 언어 지원의 지속적인 발전으로 인해 유지 관리 부담이 증가합니다.

요컨대, 비동기 Rust는 사용하기가 더 어렵고 동기 Rust보다 유지 관리 부담이 높을 수 있지만 그 대가로 동급 최고의 성능을 제공합니다. 비동기 Rust의 모든 영역은 지속적으로 개선되고 있으므로 시간이 지나면 이러한 문제의 영향은 사라질 것입니다.

## Language and library support

비동기 프로그래밍은 Rust 자체에서 지원되지만, 대부분의 비동기 애플리케이션은 커뮤니티 크레이트에서 제공하는 기능(tokie와 같은 런타임)에 의존합니다. 따라서 언어 기능과 
라이브러리 지원의 혼합에 의존해야 합니다:

- Future 특성과 같은 가장 기본적인 특성, 유형 및 함수는 표준 라이브러리에서 제공합니다.

- 비동기/대기 구문은 Rust 컴파일러에서 직접 지원합니다.

- 많은 유틸리티 유형, 매크로 및 함수는 퓨처 크레이트에서 제공됩니다. 이러한 유틸리티는 모든 비동기 Rust 애플리케이션에서 사용할 수 있습니다.

- 비동기 코드의 실행, IO 및 태스크 스폰은 Tokio 및 async-std와 같은 "비동기 런타임"에서 제공합니다. 대부분의 비동기 애플리케이션과 일부 비동기 크레이트는 특정 런타임에 의존합니다. 자세한 내용은 "비동기 생태계" 섹션을 참조하세요.

동기식 Rust에서 익숙한 일부 언어 기능은 아직 비동기식 Rust에서 사용할 수 없습니다. 특히 트레이트에서 비동기 함수를 선언할 수 없습니다. 대신, 동일한 결과를 얻으려면 좀 더 장황한 해결 방법을 사용해야 합니다

## Compiling and debugging

대부분의 경우, 비동기 Rust의 컴파일러 및 런타임 에러는 Rust에서 항상 그랬던 것과 동일한 방식으로 작동합니다. 몇 가지 주목할 만한 차이점이 있습니다:

### Compilation errors

비동기 Rust의 컴파일 오류는 동기 Rust와 동일한 높은 표준을 따르지만, 비동기 Rust는 수명 및 고정과 같은 더 복잡한 언어 기능에 의존하는 경우가 많으므로 이러한 유형의 오류가 더 자주 발생할 수 있습니다.

### New failure modes

예를 들어 비동기 컨텍스트에서 차단 함수를 호출하거나 Future 특성을 잘못 구현한 경우와 같이 비동기 Rust에서는 몇 가지 새로운 오류 모드가 발생할 수 있습니다. 이러한 오류는 컴파일러는 물론 때로는 단위 테스트까지 조용히 통과할 수 있습니다. 이 책이 목표로 하는 기본 개념을 확실히 이해하면 이러한 함정을 피하는 데 도움이 될 수 있습니다.


## Compatibility considerations

비동기 코드와 동기 코드를 항상 자유롭게 결합할 수 있는 것은 아닙니다. 예를 들어 동기 함수에서 비동기 함수를 직접 호출할 수 없습니다. 또한 동기 코드와 비동기 코드는 서로 다른 디자인 패턴을 장려하는 경향이 있어 서로 다른 환경에 맞는 코드를 작성하기 어려울 수 있습니다.

비동기 코드도 항상 자유롭게 조합할 수 있는 것은 아닙니다. 일부 크레이트는 특정 비동기 런타임에 의존하여 작동합니다. 이러한 경우 일반적으로 크레이트의 종속성 목록에 명시되어 있습니다.

이러한 호환성 문제로 인해 옵션이 제한될 수 있으므로 어떤 비동기 런타임과 어떤 크레이트가 필요한지 미리 조사해 보세요. 일단 런타임에 익숙해지면 호환성에 대해 크게 걱정할 필요가 없습니다.

## Performance characteristics

비동기 Rust의 성능은 사용 중인 비동기 런타임의 구현에 따라 달라집니다. 비동기 Rust 애플리케이션을 구동하는 런타임은 비교적 새로운 것이지만, 대부분의 실제 워크로드에서 매우 뛰어난 성능을 발휘합니다.

즉, 대부분의 비동기 생태계는 멀티스레드 런타임을 가정합니다. 따라서 단일 스레드 비동기 애플리케이션의 이론적 성능 이점, 즉 더 저렴한 동기화의 이점을 누리기 어렵습니다. 간과되는 또 다른 사용 사례는 지연 시간에 민감한 작업으로, 드라이버, GUI 애플리케이션 등에 중요합니다. 이러한 작업은 런타임 및/또는 OS 지원에 따라 적절하게 스케줄링될 수 있습니다. 향후 이러한 사용 사례에 대한 라이브러리 지원이 개선될 것으로 기대할 수 있습니다.


