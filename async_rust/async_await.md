# async / await 

첫 번째 장에서는 async/.await에 대해 간략하게 살펴봤습니다. 이번 장에서는 async/.await에 대해 좀 더 자세히 설명하면서 작동 방식과 비동기 코드가 기존 Rust 프로그램과 어떻게 다른지 설명합니다.

async/.await은 현재 스레드를 차단하는 대신 제어권을 넘겨주어 작업이 완료되기를 기다리는 동안 다른 코드가 진행되도록 하는 특별한 Rust 구문입니다.

비동기를 사용하는 방법에는 크게 두 가지가 있습니다: async fn과 async 블록. 각각 Future 
트레이트를 구현하는 값(인스턴스)을 반환합니다:
```rust
// `foo()` returns a type that implements `Future<Output = u8>`.
// `foo().await` will result in a value of type `u8`.
async fn foo() -> u8 { 5 }

fn bar() -> impl Future<Output = u8> {
    // This `async` block results in a type that implements
    // `Future<Output = u8>`.
    async {
        let x: u8 = foo().await;
        x + 5
    }
}
```

첫 번째 장에서 살펴본 것처럼 비동기 객체와 다른 퓨처는 실행될 때까지 아무것도 하지 않는 게으른 객체입니다. 퓨처를 실행하는 가장 일반적인 방법은 .await을 사용하는 것입니다. 퓨처에서 .await을 호출하면 퓨처가 완료될 때까지 실행을 시도합니다. 퓨처가 차단되면 현재 스레드에 대한 제어권을 반환합니다. 더 많은 진전이 이루어지면 실행자가 퓨처를 선택하고 실행을 재개하여 .await이 해결될 수 있도록 합니다.

## async Lifetimes

기존 함수와 달리 참조 또는 기타 '정적'이 아닌 인수를 받는 비동기 함수는 인수의 수명에 의해 제한되는 Future를 반환합니다:
```rust
// This function:
async fn foo(x: &u8) -> u8 { *x }

// Is equivalent to this function:
fn foo_expanded<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {
    async move { *x }
}
```

즉, 비동기 함수에서 반환되는 Future는 정적이 아닌 인수가 여전히 유효한 동안 await해야 
합니다. 함수를 호출한 직후에 Future를 .await하는 일반적인 경우(예: foo(&x).await)에는 
문제가 되지 않습니다. 그러나 미래를 저장하거나 다른 작업이나 스레드로 전송하는 경우 
문제가 될 수 있습니다.

참조를 인자로 사용하는 비동기 함수를 '정적 Future'로 바꾸는 일반적인 해결 방법 중 하나는 
비동기 블록 내에서 비동기 함수에 대한 호출과 함께 인수를 번들로 묶는 것입니다:
```rust
fn bad() -> impl Future<Output = u8> {
    let x = 5;
    borrow_x(&x) // ERROR: `x` does not live long enough
}

fn good() -> impl Future<Output = u8> {
    async {
        let x = 5;
        borrow_x(&x).await
    }
}
```
인수를 비동기 블록으로 이동하면 호출에서 반환된 Future의 수명과 일치하도록 수명이 연장됩니다.

## async move

비동기 블록과 클로저는 일반 클로저와 마찬가지로 move 키워드를 허용합니다. 비동기 이동 블록은 참조하는 변수의 소유권을 가져와 현재 범위보다 오래 사용할 수 있지만 다른 코드와 변수를 공유할 수 있는 기능은 포기해야 합니다:

```rust
/// `async` block:
///
/// Multiple different `async` blocks can access the same local variable
/// so long as they're executed within the variable's scope
async fn blocks() {
    let my_string = "foo".to_string();

    let future_one = async {
        // ...
        println!("{my_string}");
    };

    let future_two = async {
        // ...
        println!("{my_string}");
    };

    // Run both futures to completion, printing "foo" twice:
    let ((), ()) = futures::join!(future_one, future_two);
}

/// `async move` block:
///
/// Only one `async move` block can access the same captured variable, since
/// captures are moved into the `Future` generated by the `async move` block.
/// However, this allows the `Future` to outlive the original scope of the
/// variable:
fn move_block() -> impl Future<Output = ()> {
    let my_string = "foo".to_string();
    async move {
        // ...
        println!("{my_string}");
    }
}
```

## awaiting on a multithreaded executor

멀티스레드 퓨처 실행기를 사용하는 경우 퓨처는 스레드 간에 이동할 수 있으므로 비동기 몸체에
사용되는 모든 변수는 스레드 간에 이동할 수 있어야 하며, .await은 잠재적으로 새 스레드로 
전환될 수 있으므로 주의하세요.

즉, Send 특성을 구현하지 않는 유형에 대한 참조를 포함하여 Rc, &RefCell 또는 기타 Send 
특성을 구현하지 않는 유형을 사용하는 것은 안전하지 않습니다.

(주의: 이러한 유형은 .await 호출 중에 범위 내에 있지 않은 한 사용할 수 있습니다.)

마찬가지로, .await에 퓨처를 인식하지 않는 기존의 잠금을 유지하는 것은 스레드 풀을 잠그는 원인이 될 수 있으므로 좋지 않습니다. 한 작업이 잠금을 해제하고 실행자에게 양보하면 다른 
작업이 잠금을 해제하려고 시도하여 교착 상태를 유발할 수 있습니다. 이를 방지하려면 
std::sync의 뮤텍스가 아닌 futures::lock의 뮤텍스를 사용하세요.



