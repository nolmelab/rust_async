# pinning

퓨처를 폴링하려면 Pin<T>라는 특수 유형을 사용하여 고정해야 합니다. 이전 섹션 "퓨처와 작업
실행하기"에서 퓨처 특성에 대한 설명을 읽으셨다면, Future::poll() 정의에 있는 self: Pin<&mut Self>에서 Pin을 알아볼 수 있을 겁니다. 하지만 Pin은 무엇을 의미하며 왜 필요할까요?

## why pinning

Pin은 Unpin 마커와 함께 작동합니다. Pin을 사용하면 !Unpin을 구현하는 객체가 절대 이동되지 
않도록 보장할 수 있습니다. 이것이 왜 필요한지 이해하려면 async/.await의 작동 방식을 기억해야
합니다. 다음 코드를 살펴봅시다:
```rust
let fut_one = /* ... */;
let fut_two = /* ... */;
async move {
    fut_one.await;
    fut_two.await;
}
```

내부적으로는 Future를 구현하는 익명 유형을 생성하여 다음과 같은 폴링 메서드를 제공합니다:
```rust
// The `Future` type generated by our `async { ... }` block
struct AsyncFuture {
    fut_one: FutOne,
    fut_two: FutTwo,
    state: State,
}

// List of states our `async` block can be in
enum State {
    AwaitingFutOne,
    AwaitingFutTwo,
    Done,
}

impl Future for AsyncFuture {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        loop {
            match self.state {
                State::AwaitingFutOne => match self.fut_one.poll(..) {
                    Poll::Ready(()) => self.state = State::AwaitingFutTwo,
                    Poll::Pending => return Poll::Pending,
                }
                State::AwaitingFutTwo => match self.fut_two.poll(..) {
                    Poll::Ready(()) => self.state = State::Done,
                    Poll::Pending => return Poll::Pending,
                }
                State::Done => return Poll::Ready(()),
            }
        }
    }
}
```

poll이 처음 호출되면, fut_one을 폴링합니다. fut_one이 완료되지 못하면 AsyncFuture::poll이
반환(Pending으로) 됩니다. 이후 폴링 호출은 이전 폴링이 중단된 지점에서 다시 시작됩니다. 
이 프로세스는 퓨처가 성공적으로 완료할 수 있을 때까지 계속됩니다.

하지만 참조를 사용하는 비동기 블록이 있다면 어떻게 될까요? 예를 들어
```rust
async {
    let mut x = [0; 128];
    let read_into_buf_fut = read_into_buf(&mut x);
    read_into_buf_fut.await;
    println!("{:?}", x);
}
```

위 코드는 어떤 구조로 컴파일될까요?

```rust
struct ReadIntoBuf<'a> {
    buf: &'a mut [u8], // points to `x` below
}

struct AsyncFuture {
    x: [u8; 128],
    read_into_buf_fut: ReadIntoBuf<'what_lifetime?>,
}
```

여기서 ReadIntoBuf 퓨처는 구조체의 다른 필드인 x에 대한 참조를 보유합니다. 그러나 
AsyncFuture가 이동하면 x의 위치도 함께 이동하여 read_into_buf_fut.buf에 저장된 포인터가 
무효화됩니다.

퓨처를 메모리의 특정 지점에 고정하면 이 문제를 방지할 수 있으므로 비동기 블록 내에서 값에 
대한 참조를 안전하게 생성할 수 있습니다.

## Pinning in detail

조금 더 간단한 예를 통해 Pin(고정)을 이해해 보겠습니다. 위에서 직면한 문제는 궁극적으로 
Rust에서 자체 참조 유형에서 참조를 처리하는 방식으로 귀결되는 문제입니다.

지금 예제는 다음과 같습니다:
```rust
#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
}

impl Test {
    fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
        }
    }

    fn init(&mut self) {
        let self_ref: *const String = &self.a;
        self.b = self_ref;
    }

    fn a(&self) -> &str {
        &self.a
    }

    fn b(&self) -> &String {
        assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
        unsafe { &*(self.b) }
    }
}
```

Test는 a와 b 필드의 값에 대한 참조를 가져오는 메서드를 제공합니다. b는 a에 대한 참조이므로 
Rust의 빌림 규칙에 따라 이 수명을 정의할 수 없으므로 포인터로 저장합니다. 이제 자기 참조 
구조체라고 부르는 것이 생겼습니다.

이 예제를 실행해 보면 알 수 있듯이 데이터를 이동하지 않으면 예제가 정상적으로 작동합니다:
```rust
fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();

    println!("a: {}, b: {}", test1.a(), test1.b());
    println!("a: {}, b: {}", test2.a(), test2.b());

}
```
기대한 대로 결과를 얻었습니다:
```bash
a: test1, b: test1
a: test2, b: test2
```

test1을 test2로 바꾸어 데이터를 이동하면 어떤 일이 발생하는지 살펴보겠습니다:
```rust
fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();

    println!("a: {}, b: {}", test1.a(), test1.b());
    std::mem::swap(&mut test1, &mut test2);
    println!("a: {}, b: {}", test2.a(), test2.b());

}
```

Naively, we could think that what we should get a debug print of test1 two times like this:

```bash
a: test1, b: test1
a: test1, b: test1
```

But instead we get:

```rust
a: test1, b: test1
a: test1, b: test2
```

test2.b에 대한 포인터는 여전히 test1 내부에 있는 이전 위치를 가리킵니다. 이 구조체는 더 이상 
자체 참조가 아니며 다른 객체의 필드에 대한 포인터를 보유합니다. 즉, test2.b의 수명을 더 이상 
test2의 수명에 의존할 수 없습니다.

아직도 확신이 서지 않으시다면 이 정도는 이해하실 수 있을 것입니다:
```rust
fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();

    println!("a: {}, b: {}", test1.a(), test1.b());
    std::mem::swap(&mut test1, &mut test2);
    test1.a = "I've totally changed now!".to_string();
    println!("a: {}, b: {}", test2.a(), test2.b());

}
```

[ ] Add image of memory layout

## Pinning in practice

고정(Pinning)과 핀 타잎이 이 문제를 해결하는 데 어떻게 도움이 되는지 살펴보겠습니다.

Pin 타입은 포인터 타입을 래핑하여 Unpin을 구현하지 않는 경우 포인터 뒤의 값이 이동되지 
않도록 보장합니다. 예를 들어 Pin<&mut T>, Pin<&T>, Pin<Box<T>>는 모두 T: !Unpin일 경우 
T가 이동되지 않도록 보장합니다.

대부분의 타입은 이동에 문제가 없습니다. 이러한 형은 Unpin이라는 형질을 구현합니다. Unpin 타잎에 대한 포인터는 Pin에 자유롭게 넣거나 뺄 수 있습니다. 예를 들어, u8은 Unpin이므로 
Pin<&mut u8>은 일반 &mut u8처럼 동작합니다.

그러나 고정된 후에는 이동할 수 없는 유형에는 !Unpin이라는 마커가 있습니다. 
async/await으로 생성된 퓨처가 그 예입니다.

### Pinning to the stack

예제로 돌아가 보겠습니다. Pin을 사용하면 문제를 해결할 수 있습니다. 대신 고정된 포인터가 필요하다면 이 예제는 어떻게 될지 살펴보겠습니다:
```rust
use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}


impl Test {
    fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned, // This makes our type `!Unpin`
        }
    }

    fn init(self: Pin<&mut Self>) {
        let self_ptr: *const String = &self.a;
        let this = unsafe { self.get_unchecked_mut() };
        this.b = self_ptr;
    }

    fn a(self: Pin<&Self>) -> &str {
        &self.get_ref().a
    }

    fn b(self: Pin<&Self>) -> &String {
        assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
        unsafe { &*(self.b) }
    }
}
```

우리 타입이 !Unpin을 구현하는 경우 객체를 스택에 고정하는 것은 항상 안전하지 않습니다. 스택에 고정할 때 안전하지 않은 코드를 직접 작성하지 않으려면 pin_utils와 같은 크레이트를 사용하면 됩니다.

아래에서는 test1과 test2 객체를 스택에 고정합니다:
```rust
pub fn main() {
    // test1 is safe to move before we initialize it
    let mut test1 = Test::new("test1");
    // Notice how we shadow `test1` to prevent it from being accessed again
    let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new("test2");
    let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };
    Test::init(test2.as_mut());

    println!("a: {}, b: {}", Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    println!("a: {}, b: {}", Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
```

이제 데이터를 이동하려고 하면 컴파일 오류가 발생합니다:
```rust
pub fn main() {
    let mut test1 = Test::new("test1");
    let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new("test2");
    let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };
    Test::init(test2.as_mut());

    println!("a: {}, b: {}", Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    std::mem::swap(test1.get_mut(), test2.get_mut());
    println!("a: {}, b: {}", Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
```

```rust
error[E0277]: `PhantomPinned` cannot be unpinned
   --> src\test.rs:56:30
    |
56  |         std::mem::swap(test1.get_mut(), test2.get_mut());
    |                              ^^^^^^^ within `test1::Test`, the trait `Unpin` is not implemented for `PhantomPinned`
    |
    = note: consider using `Box::pin`
note: required because it appears within the type `test1::Test`
   --> src\test.rs:7:8
    |
7   | struct Test {
    |        ^^^^
note: required by a bound in `std::pin::Pin::<&'a mut T>::get_mut`
   --> <...>rustlib/src/rust\library\core\src\pin.rs:748:12
    |
748 |         T: Unpin,
    |            ^^^^^ required by this bound in `std::pin::Pin::<&'a mut T>::get_mut`
```

### pinning to the heap

!Unpin 타잎을 힙에 고정하면 데이터에 안정적인 주소가 부여되므로 고정된 후에는 가리키는 
데이터를 이동할 수 없습니다. 스택 고정과 달리, 객체의 수명 동안 데이터가 고정된다는 것을 
알 수 있습니다.

```rust
use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {
    fn new(txt: &str) -> Pin<Box<Self>> {
        let t = Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned,
        };
        let mut boxed = Box::pin(t);
        let self_ptr: *const String = &boxed.a;
        unsafe { boxed.as_mut().get_unchecked_mut().b = self_ptr };

        boxed
    }

    fn a(self: Pin<&Self>) -> &str {
        &self.get_ref().a
    }

    fn b(self: Pin<&Self>) -> &String {
        unsafe { &*(self.b) }
    }
}

pub fn main() {
    let test1 = Test::new("test1");
    let test2 = Test::new("test2");

    println!("a: {}, b: {}",test1.as_ref().a(), test1.as_ref().b());
    println!("a: {}, b: {}",test2.as_ref().a(), test2.as_ref().b());
}
```

일부 함수는 함께 작동하는 퓨처가 언핀이어야 합니다. 언핀 타입이 필요한 함수에 언핀이 아닌
퓨처나 스트림을 사용하려면, 먼저 Box::pin(Pin<Box<T>>를 생성) 또는
pin_utils::pin_mut! 매크로(Pin<&mut T>를 생성)를 사용해 값을 핀해야 합니다. 
Pin<Box<Fut>>와 Pin<&mut Fut>은 모두 퓨처로 사용할 수 있으며, 둘 다 언핀을 구현합니다.
```rust
use pin_utils::pin_mut; // `pin_utils` is a handy crate available on crates.io

// A function which takes a `Future` that implements `Unpin`.
fn execute_unpin_future(x: impl Future<Output = ()> + Unpin) { /* ... */ }

let fut = async { /* ... */ };
execute_unpin_future(fut); // Error: `fut` does not implement `Unpin` trait

// Pinning with `Box`:
let fut = async { /* ... */ };
let fut = Box::pin(fut);
execute_unpin_future(fut); // OK

// Pinning with `pin_mut!`:
let fut = async { /* ... */ };
pin_mut!(fut);
execute_unpin_future(fut); // OK
```

## Summary 

- T: Unpin(기본값)이면 Pin<'a, T>는 &'a mut T와 완전히 동일합니다: Unpin은 고정된(Pinned) 
상태에서도 이 타입을 이동해도 괜찮다는 의미이므로 Pin은 이러한 타입에 아무런 영향을
미치지 않습니다.

- &mut T를 고정된(Pinned) T에 가져오려면 T: !Unpin일 때는 unsafe 필요로 합니다.

- 대부분의 표준 라이브러리 형은 Unpin을 구현합니다. Rust에서 접하는 대부분의 "일반" 형도 
마찬가지입니다. async/await에 의해 생성된 Future는 이 규칙의 예외입니다.

- Nightly 기능 플래그를 사용하여 타잎에 !Unpin 바인딩을 추가하거나, Stable 버전에는 타잎에
std::marker::PhantomPinned를 추가하면 됩니다.

- 데이터를 스택이나 힙에 고정할 수 있습니다.

- 스택에 !Unpin 객체를 고정하려면 unsafe를 필요로 합니다.

- !Unpin 객체를 힙에 고정하는 데는 안전하지 않은 상태가 필요하지 않습니다. Box::pin을 
사용하면 됩니다. 

- 고정된 (Pinned) T: !Unpin 데이터의 경우 고정된 순간부터 drop이 호출될 때까지 해당 
메모리가 무효화되거나 용도가 변경되지 않는다는 불변성을 유지해야 합니다. 이는 핀 
계약(Contract)에서 중요한 부분입니다.

<details>

<summary> 놀미 노트 </summary> 

Pin을 자기 참조가 있는 경우 메모리 이동이 되면 무효화되므로 이동을 막는 기능입니다. 그래서
고정한다는 뜻의 Pin을 사용합니다. 

async 블럭이나 함수를 컴파일러가 생성한 Future 코드는 자기 참조가 있을 수 있습니다. 꽤 
많은 경우 자기 참조가 있을 것입니다. 따라서, Future의 리시버(수신자)인 자기 자신은 
Pin (고정) 되어야 합니다. 

스택에 고정하는 경우 unsafe 코드를 사용했습니다. Pin::new_unchecked()에서 스택에 있는 
변수의 메모리를 사용해서 고정했습니다. 스택 메모리에 생성된 객체를 고정한다는 뜻으로 
pinning to stack이라고 했습니다. 영어 어법을 한글에 익숙한 사람이 이해하려니 처음에 
좀 어려운 면이 있습니다. 흔한 일입니다. 

</details>

